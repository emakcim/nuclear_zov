import cv2
import cv2.aruco as aruco
from numpy import *
import time
from math import *

def opros():
    return int(input('Введите 0, если пользуетесь вебкамом или 1, если подключили камеру: '))

def center_trapation(vertices):
    # Исходные координаты вершин трапеции (формат: array([[[x1, y1], [x2, y2], [x3, y3], [x4, y4]]])
    points = vertices.reshape(-1, 2)
    center_x = mean(points[:, 0])
    center_y = mean(points[:, 1])
    return [float(center_x), float(center_y)]


def calibration(real_distance, all_good_markers):
    all_good_markers.sort()
    pixel_distance = dist([all_good_markers[0], all_good_markers[-1]])
    return pixel_distance / real_distance  # Пикселей на единицу длины (например, 50 px/см)



while True:
    try:
        mode = opros()
        if mode in [0, 1]:
            break
    except:
        pass

# 0 — индекс камеры (если у тебя одна камера, обычно 0)
cap = cv2.VideoCapture(mode)

if not cap.isOpened():
    print("Не удалось открыть камеру")
    exit()


while True:
    ret, frame = cap.read()  # считываем кадр
    if not ret:
        print("Не удалось получить кадр")
        break

    frame = cv2.rotate(frame, 180)

    all_good_markers = []

    good_square_dict = aruco.getPredefinedDictionary(aruco.DICT_4X4_1000)
    bad_square_dict = aruco.getPredefinedDictionary(aruco.DICT_5X5_1000)
    parameters = aruco.DetectorParameters()

    frame_gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    _, thresh = cv2.threshold(frame_gray, 127, 255, cv2.THRESH_BINARY)

    contours, _ = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
    good_coordination, good_ids, _ = aruco.detectMarkers(frame_gray, good_square_dict, parameters=parameters)
    bad_coordination, bad_ids, _ = aruco.detectMarkers(frame_gray, bad_square_dict, parameters=parameters)

    for cnt in contours:
        # Аппроксимируем контур многоугольником
        epsilon = 0.02 * cv2.arcLength(cnt, True)
        approx = cv2.approxPolyDP(cnt, epsilon, True)

        # Если контур имеет 4 вершины — возможно прямоугольник
        if len(approx) == 4:
            # Дополнительно можно проверить, что контур выпуклый и площадь больше минимальной
            if cv2.isContourConvex(approx) and cv2.contourArea(approx) > 1000:
                # Рисуем контур
                cv2.drawContours(frame, [approx], 0, (0, 255, 0), 3)

    if good_ids is not None:
        print(f"Обнаружены маркеры с ID: {good_ids.flatten()}")
        # Отрисовка контуров вокруг найденных маркеров
        aruco.drawDetectedMarkers(frame, good_coordination, good_ids)
        # print(good_coordination)
        # print(good_ids)

        # Объединение всех хороших точек. В том числе для дальнейшей калибровки.

        for array in good_coordination:
            all_good_markers.append(center_trapation(array))

        px_ratio = calibration(sqrt(180_000), all_good_markers)


    if bad_ids is not None:
        print(f"Обнаружены маркеры с ID: {bad_ids.flatten()}")
        # Отрисовка контуров вокруг найденных маркеров
        aruco.drawDetectedMarkers(frame, bad_coordination, bad_ids)
    


    

    
    cv2.imshow('USB камера', frame)  # показываем кадр

    # Нажми 'q' чтобы выйти
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

    # time.sleep(2.5)

# Освобождаем ресурсы
cap.release()
cv2.destroyAllWindows()






