import cv2
import cv2.aruco as aruco
from numpy import *
from time import *
from math import *

A, B = 155.0, 400.0

def opros():
    return int(input('Введите 0, если пользуетесь вебкамом или 1, если подключили камеру: '))

def center_trapation(vertices):
    # Исходные координаты вершин трапеции (формат: array([[[x1, y1], [x2, y2], [x3, y3], [x4, y4]]])
    points = vertices.reshape(-1, 2)
    center_x = mean(points[:, 0])
    center_y = mean(points[:, 1])
    return [float(center_x), float(center_y)]


def calibration(real_distance, all_good_markers, ids):
    # all_good_markers.sort(key=lambda x: x[1])
    # print(ids[all_good_markers.index(all_good_markers[0])], ids[all_good_markers.index(all_good_markers[-1])])
    # pixel_distance = dist(all_good_markers[0], all_good_markers[-1])
    list_ids = ids.tolist()
    try:
        pixel_distance = dist(all_good_markers[list_ids.index([0])], all_good_markers[list_ids.index([3])])
        rotatio = real_distance / pixel_distance
        a, b = all_good_markers[list_ids.index([0])]
        return rotatio, a*rotatio, b*rotatio  # Пикселей на единицу длины (например, 50 px/см)
    except:
        return 0, 0, 0

def coordinations(centers, ids, rotation_mode, px_ratio, a, b):
    adapted_centers = {}
    for n in range(len(centers)):
        x, y = centers[n]
        adapted_centers[str(ids[n])] = [x*px_ratio - A - a, B + b - y*px_ratio, rotation_mode[n]]
    return adapted_centers

while True:
    try:
        mode = opros()
        if mode in [0, 1]:
            break
    except:
        pass

# 0 — индекс камеры (если у тебя одна камера, обычно 0)
cap = cv2.VideoCapture(mode)

if not cap.isOpened():
    print("Не удалось открыть камеру")
    exit()

counter = 5
last_time = time()
dict_good_markers = {}
dict_bad_markers = {}

while counter > 0:
    ret, frame = cap.read()  # считываем кадр
    if not ret:
        print("Не удалось получить кадр")
        break

    frame_rotate = cv2.rotate(frame, cv2.ROTATE_180)

    all_good_markers = []
    all_bad_markers = []
    marker_angles_of_bad = []
    marker_angles_of_good = []
    px_ratio = a = b = 0

    good_square_dict = aruco.getPredefinedDictionary(aruco.DICT_4X4_1000)
    bad_square_dict = aruco.getPredefinedDictionary(aruco.DICT_5X5_1000)
    parameters = aruco.DetectorParameters()

    frame_gray = cv2.cvtColor(frame_rotate, cv2.COLOR_BGR2GRAY)
    _, thresh = cv2.threshold(frame_gray, 127, 255, cv2.THRESH_BINARY)

    contours, _ = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
    good_coordination, good_ids, _ = aruco.detectMarkers(frame_gray, good_square_dict, parameters=parameters)
    bad_coordination, bad_ids, _ = aruco.detectMarkers(frame_gray, bad_square_dict, parameters=parameters)

    for cnt in contours:
        # Аппроксимируем контур многоугольником
        epsilon = 0.02 * cv2.arcLength(cnt, True)
        approx = cv2.approxPolyDP(cnt, epsilon, True)

        # Если контур имеет 4 вершины — возможно прямоугольник
        if len(approx) == 4:
            # Дополнительно можно проверить, что контур выпуклый и площадь больше минимальной
            if cv2.isContourConvex(approx) and cv2.contourArea(approx) > 1000:
                # Рисуем контур
                cv2.drawContours(frame_rotate, [approx], 0, (0, 255, 0), 3)

    if good_ids is not None:
        # print(f"Обнаружены маркеры с ID: {good_ids.flatten()}")
        # Отрисовка контуров вокруг найденных маркеров
        aruco.drawDetectedMarkers(frame_rotate, good_coordination, good_ids)

        for i in range(len(good_ids)):
            # Получаем углы текущего маркера
            marker_corners = good_coordination[i].reshape((4, 2))
            
            # Вычисляем вектор между верхними углами
            dx = marker_corners[1][0] - marker_corners[0][0]
            dy = marker_corners[1][1] - marker_corners[0][1]
            
            # Вычисляем угол в градусах
            angle_deg = degrees(arctan2(dy, dx))
            
            # Добавляем ID маркера и угол в список
            marker_angles_of_good.append(angle_deg)
            
            # Выводим информацию для текущего маркера
            # print(f"Маркер ID {good_ids[i][0]}: угол поворота {angle_deg:.2f}°")


        # Объединение всех хороших точек. В том числе для дальнейшей калибровки.

        for array in good_coordination:
            all_good_markers.append(center_trapation(array))

        px_ratio, a, b = calibration(300, all_good_markers, good_ids)


    if bad_ids is not None:
        # print(f"Обнаружены маркеры с ID: {bad_ids.flatten()}")
        # Отрисовка контуров вокруг найденных маркеров

        for i in range(len(bad_ids)):
            # Получаем углы текущего маркера
            marker_corners = bad_coordination[i].reshape((4, 2))
            
            # Вычисляем вектор между верхними углами
            dx = marker_corners[1][0] - marker_corners[0][0]
            dy = marker_corners[1][1] - marker_corners[0][1]
            
            # Вычисляем угол в градусах
            angle_deg = degrees(arctan2(dy, dx))
            
            # Добавляем ID маркера и угол в список
            marker_angles_of_bad.append(angle_deg)
            
            # Выводим информацию для текущего маркера
            # print(f"Маркер ID {bad_ids[i][0]}: угол поворота {angle_deg:.2f}°")

        aruco.drawDetectedMarkers(frame_rotate, bad_coordination, bad_ids)

        for array in bad_coordination:
            all_bad_markers.append(center_trapation(array))

    # короче теперь все наши центры превращаем в словари, 
    # в которых указан тип маркера и его координаты для манипулятора

    dict_good_markers = coordinations(all_good_markers, good_ids, marker_angles_of_good, px_ratio, a, b)
    dict_bad_markers = coordinations(all_bad_markers, bad_ids, marker_angles_of_bad, px_ratio, a, b)
    
    cv2.imshow('USB камера', frame_rotate)  # показываем кадр

    # Нажми 'q' чтобы выйти
    if cv2.waitKey(1) & 0xFF == ord('q'):
        # Освобождаем ресурсы
        cap.release()
        cv2.destroyAllWindows()
        break

    if time() - last_time > 1.0:
        print(f'У вас осталось {counter} секунд(-ы)!')
        counter -= 1
        last_time = time()

    # time.sleep(2.5)

print(dict_good_markers)
print(dict_bad_markers)
